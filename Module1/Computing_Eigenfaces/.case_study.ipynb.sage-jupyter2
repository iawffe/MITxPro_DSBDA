{"type":"settings","kernel":"anaconda3","backend_state":"running","trust":true,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.13"}},"kernel_usage":{"cpu":0,"memory":216076288},"kernel_state":"idle"}
{"type":"file","last_load":1509512781636}
{"type":"cell","id":"588c87","pos":0,"input":"- **Objective:** To classify faces in photo images using Principle Component Analysis (PCA) \n- **Instruction Material:** Located in \\Instruction\\ \n- **Data:** Images located in \\Reference_Files\\\n- **Good Read:**:\n    - https://en.wikipedia.org/wiki/Eigenface\n    - http://jmcspot.com/Eigenface/\n    - https://www.bytefish.de/pdf/facerec_python.pdf\n    - http://sebastianraschka.com/Articles/2015_pca_in_3_steps.html\n    - http://arnauddelorme.com/ica_for_dummies/\n    - http://www.itl.nist.gov/div898/handbook/pmc/section5/pmc541.htm\n    - http://setosa.io/ev/principal-component-analysis/","cell_type":"markdown"}
{"exec_count":1,"start":1509875292551,"input":"import os\nimport numpy as np\nfrom PIL import Image\nimport matplotlib.pyplot as plt\n%matplotlib inline","state":"done","pos":1,"cell_type":"code","type":"cell","end":1509875292558,"id":"5c1487","kernel":"anaconda3"}
{"output":{"0":{"name":"stdout","text":"['14.jpg', '2.jpg', '13.jpg', '5.jpg', '12.jpg', '4.jpg', '3.jpg', '9.jpg', '11.jpg', '7.jpg', '10.jpg', '6.jpg', '1.jpg', '8.jpg']\n14\n14\n(300, 300)\nfloat64\n"},"1":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"59b3f5d77365db5c511760b96fc4ad47de6bb931"}},"2":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"6943d113208c28f5ba8e305b45e9fd542d57cc13"}},"3":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"b73e60a73f6f9cf51c10aa83afb6d91f3174c4d7"}},"4":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"6355e91b5056e293683c1cf995dc8bf8a7054296"}}},"exec_count":2,"start":1509875292561,"input":"# look for all images files, aka data, in the Reference_File folder\noim_files = os.listdir('Reference_Files')\nprint(oim_files)\nimage_count = len(oim_files)\nprint(image_count) # number of images\n\n# open images, convert to grayscale and resize to 300x300\nim = [np.array(Image.open( '/'.join( [\"Reference_Files\", img] )).convert('L').resize((300,300),Image.ANTIALIAS), dtype=float) for img in oim_files]\nprint(len(im))\nprint(im[0].shape)\nprint(im[0].dtype)\n\n# let's have a peek of our first 4 images\nfor i in range(4):\n    plt.imshow(im[i], cmap='gray', vmin = 0, vmax = 255)\n    plt.show()","scrolled":true,"state":"done","pos":2,"type":"cell","end":1509875295060,"id":"84715c","kernel":"anaconda3"}
{"output":{"0":{"name":"stdout","text":"(90000, 14)\nfloat64\n"}},"exec_count":3,"start":1509875295083,"input":"# flatten\n\n# matrix S will store all images with each column represent each flattened image\nS = np.zeros((14, 300*300), dtype=float)\nfor i, imm in enumerate(im):\n    # now this is a 1 by 300x300 row\n    im_row = imm.flatten()\n    S[i,:] = im_row \nS = S.T\n\nprint(S.shape)\nprint(S.dtype)","state":"done","pos":4,"type":"cell","end":1509875295104,"id":"49c873","kernel":"anaconda3"}
{"type":"cell","id":"4bae77","pos":5,"input":"---\nSubstract each image columns in S by the Mean Face, result matrix is a 300*300 by 14 matrix SS\n\n---","cell_type":"markdown"}
{"output":{"0":{"name":"stdout","text":"(90000,)\n"},"1":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f539eea5860>"},"exec_count":4},"2":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"a995ee85db185001f56ac80cba9bba3af6881fd9"}}},"exec_count":4,"start":1509875295116,"input":"# calculate the \"mean\" face for all (14) images  :p the mean face -> .\\_/.\n# which is pretty much a column vector (300*300 by 1) for each element is the mean of each row\nmean_face = np.mean(S, axis=1) # to take the mean of each row \nprint(mean_face.shape)\n\n# let's take a peek of the mean_face\nplt.imshow(mean_face.reshape(300,300), cmap='gray', vmin = 0, vmax = 255)","state":"done","pos":4.5,"type":"cell","end":1509875295760,"id":"c834fa","kernel":"anaconda3"}
{"type":"cell","id":"c66847","pos":3.5,"input":"---\nFirst of all, flattern each image to a row of pixels, then tranpose it as an \"image vector\"\n\n---","cell_type":"markdown"}
{"type":"cell","id":"a0d1d2","pos":4.25,"input":"---\nThen we calculate the Mean Face\n\n---","cell_type":"markdown"}
{"output":{"0":{"name":"stdout","text":"14\n(90000, 14)\n(90000, 14)\n"},"1":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"609d6426aec0e0c8520f11fd03d0a01072dafd96"}},"2":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"6609bf367232c83a206dd429098cdfb22cf2a751"}},"3":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"d294a0d8cbb088721d3fcadfc57c156626fe1921"}},"4":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"33bc3e3160bd5079cddba5c34d1057a21e16a021"}}},"exec_count":5,"start":1509875295791,"input":"print(S.shape[1])\nmf = np.atleast_2d(mean_face).T\nmean_face_matrix = np.repeat(mf, S.shape[1], axis=1)\nprint(mean_face_matrix.shape)\n\nSS = S - mean_face_matrix\nprint(SS.shape)\n\n# Let's take a peek of the first 4 Diff Face\nfor i in range(4):\n    diff_face = SS[:,i]\n    plt.imshow(diff_face.reshape(300,300), cmap='gray', vmin = 0, vmax = 255)\n    plt.show()","state":"done","pos":6,"type":"cell","end":1509875298239,"id":"9dbabc","kernel":"anaconda3"}
{"type":"cell","id":"10035b","pos":7,"input":"---\nFind the Covariance Matrix from SS and the EigenVectors and corresponding EigenValues; Sort the EigenValues\n\n---","cell_type":"markdown"}
{"output":{"0":{"name":"stdout","text":"(14, 14)\n(90000, 14)\n(90000, 14)\n"}},"exec_count":6,"start":1509875298253,"input":"# numpy.cov requires each row of the 3D matrix a variable, thus each column is a observation\n# Our SS matrix fits perfectly for this purpose. Each row of SS matrix is a pixel, a feature, aka variable\n#cov_SS = np.cov(SS) # this should result in a 300*300 by 300*300 matrix\n#print(cov_SS.shape)\n# Let C be the Covariance Matrix, and L be the smaller version\n# C will be a 90000 by 90000 matrix, and L will be a 14 by 14 matrix !!!\n\nL = np.dot(SS.T,SS)\nprint(L.shape)\n\n[eigenvalues, temp_eigenvectors] = np.linalg.eigh(L)\n\n# each real eigenvector should be a len of 90000 vector\neigenvectors = np.dot(SS, temp_eigenvectors)\nprint(eigenvectors.shape)\n# the real eigenvectors need to be normalized\nfor i in range(eigenvectors.shape[1]):\n    eigenvectors[:,i] = eigenvectors[:,i]/np.linalg.norm(eigenvectors[:,i])\n# make sure we don't lose any eigenvectors\nprint(eigenvectors.shape)\n","state":"done","pos":8,"type":"cell","end":1509875298302,"id":"618462","kernel":"anaconda3"}
{"output":{"0":{"name":"stdout","text":"[ -2.63157688e-07   1.23180883e+08   1.35171613e+08   1.58125010e+08\n   1.69434964e+08   2.10940014e+08   2.60464982e+08   2.96548784e+08\n   3.48604143e+08   3.67269140e+08   5.81637432e+08   6.43121077e+08\n   9.74513582e+08   1.85506136e+09]\n[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13]\n[13 12 11 10  9  8  7  6  5  4  3  2  1  0]\n"}},"exec_count":7,"start":1509875298382,"input":"# let's peek at our eigenvalues\nprint(eigenvalues)\n# sort the eigenvalues and get the index, sort by the descending order\nidx = np.argsort(eigenvalues)\nprint(idx)\nidx = np.flipud(idx)\nprint(idx)","state":"done","pos":9,"type":"cell","end":1509875298386,"id":"c45a9d","kernel":"anaconda3"}
{"output":{"0":{"name":"stdout","text":"(90000, 10)\n"}},"exec_count":8,"start":1509875298392,"input":"# say, we only want the 10 most significant component\nN = 10\neigenV = eigenvectors[:,idx[:10]]\nprint(eigenV.shape) # we should see 90000 by 10 ","state":"done","pos":10,"type":"cell","end":1509875298403,"id":"c96041","kernel":"anaconda3"}
{"output":{"0":{"name":"stdout","text":"(90000, 10)"},"1":{"name":"stdout","text":"\n"},"2":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"25d601525fa399de75df01e471ef5147d8a25a9c"}},"3":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"3538c1106cad7c3414ba8a85c9d3ae46ab08ce2a"}},"4":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"2076a18a4bcaaa3731f8d77c81804d3446b5820e"}},"5":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"adfd0226991dcc0365940b2ac593523968bb718b"}},"6":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"4aaa601d4a881e5cf3d424cbdb290e17d66d800e"}},"7":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"8c1ff429a6050e6a4bb557e618c029b36f4c516e"}},"8":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"523e7a8c7c7d35ed30da2331c68d55faf3c4e8bc"}},"9":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"b99bbc95a0bf3b77e4fa4cb8354f36f4fdc2ada5"}},"10":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"dcb5eb093cf3e650984f961bf16699be9c5e7296"}},"11":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"ce8c7a3167a860b0ba38a78905558d82e2b6c642"}}},"exec_count":9,"start":1509875298418,"input":"# Let's take a peek of our 10 eigenface\n\n# normalize (0..1) and scale the eigenvector to a readable color range (0..255)\nfor i in range(N):\n    emin = np.min(eigenV[:,i])\n    emax = np.max(eigenV[:,i])\n    eigenV[:,i] = ( (eigenV[:,i]-emin) / (emax-emin) ) *255\n\nprint(eigenV.shape)\n\nfor i in range(N):\n    eigen_face = eigenV[:,i]\n    plt.imshow(eigen_face.reshape(300,300), cmap='gray', vmin = 0, vmax = 255)\n    plt.show()\n","state":"done","pos":11,"type":"cell","end":1509875304790,"id":"247a35","kernel":"anaconda3"}
{"output":{"0":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"8763fa56df8b7f4690029c3eeba9a8bfd1d37ea7"}},"1":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"fbe75b772fae4e3bd0376b67c2cb2d089d54b345"}},"2":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"b2c883c61b2d4d4781ab58ecbf36fc1e8657e7ae"}},"3":{"metadata":{"image/png":{"height":251,"width":259}},"data":{"image/png":"b2f24b3a7c7f01e12793c59a460fa6e984a578b5"}}},"exec_count":10,"start":1509875304807,"input":"# Now let's try to reconstruct the first 4 faces using our 10 eigenfaces\n\nY = np.dot(eigenV.T, SS) # Y is 10 by 14 array\nX = np.dot(eigenV, Y) + mean_face_matrix # X is 900000 by 14 array\n\n# normalize and scale the faces\nfor i in range(X.shape[1]):\n    Xmin = np.min(X[:,i])\n    Xmax = np.max(X[:,i])\n    X[:,i] = ( (X[:,i]-Xmin) / (Xmax-Xmin) ) *255\n\nfor i in range(4):\n    face = X[:,i]\n    plt.imshow(face.reshape(300,300), cmap='gray', vmin = 0, vmax = 255)\n    plt.show()\n","state":"done","pos":12,"type":"cell","end":1509875307488,"id":"e6ade9","kernel":"anaconda3"}
{"type":"cell","id":"659ffd","pos":13,"input":""}